using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace WindowsFormsApp3
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void button1_Click(object sender, EventArgs e)
            //insertion sort - przez wstawianie, pierwszy jest juz posortowany,bierzemy pierwszy z nieposortowanej czesci i wstawiamy go w dobre miejsce
            //po posortowanej stronie czyli po lewej az cala tablica bedzie posortowana
        {
            int[] tab = { 2, 5, 3, 1, 8, 5, 0 };
            for (int j = 1; j < tab.Length; j++)
            {
                int obecny = tab[j];
                int i = j - 1;
                while (i >= 0 && tab[i] > obecny)
                //przesuwanie elementow ktore sa wieksze niz obecny po posortowanej stronie
                {
                    tab[i + 1] = tab[i];
                    i--;
                }
                //wstawianie obecnego w odpowiednie miejsce
                tab[i + 1] = obecny;
            }
           
            string wynik = ToString(tab);
            MessageBox.Show(wynik);
        }
        string ToString(int[] tab)
        {
            string wynik = "";
            for (int j = 0; j < tab.Length; j++)
            {
                wynik += tab[j] + " ";
            }
            return wynik;
        }

        private void button2_Click(object sender, EventArgs e)
            //bąbelkowy - najwieksza wyplywa na koniec
        {
            int[] tab = { 2, 5, 3, 1, 8, 5, 0 };
            for(int j = 0;j < tab.Length; j++)//pętla decyduje ile razy ma chodzic pętla porównująca
            {
                bool swapped = false;//zeby przerwac dzialanie i nie porównywac juz kiedy wszystkie sa posortowane wczesniej i nic sie juz nie zamienia
                for (int i = 1; i<tab.Length; i++)
                {
                    if (tab[i] < tab[i - 1])//kiedy nastepna liczba jest mniejsz niz poprzednia - zamiana
                    {
                        int temp = tab[i];
                        tab[i]= tab[i - 1];
                        tab[i - 1] = temp;
                        swapped = true;
                    }
                }
                if (swapped == false) break;
                {
                    
                }

            }
            string wynik= ToString(tab);
            MessageBox.Show(wynik);

        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void button3_Click(object sender, EventArgs e)
        {
            int[] tab = { 2, 5, 3, 1, 8, 5, 0 };
            Quicksort(tab, 0, tab.Length-1);
            string wynik= ToString(tab);
            MessageBox.Show(wynik);
        
        }
        void Quicksort(int[] tab, int l, int r)
        {
            int i = l;
            int j = r;
            int pivot = tab[l + (r - l) / 2];
            if (l < r)//zeby rekurencja nie wywolywala sie w nieskonczonosc, tylko zatrzymala sie gdy jest 0 lu 1 element i nie trzeba juz sortowac
            {
                while (i <= j)//ustawiamy mniejsze od pivota po lewej a wieksze po prawej
                {
                    while (tab[i]<pivot) { //mniejsze zostaja po lewej
                    i++;
                    }
                    while (tab[j]>pivot) {//wieksze zostaja po prawej
                        j--;
                    }
                    if(i<=j)//zamiana tych wiekszych ze strony lewej z mniejszymi ze strony prawej
                    {
                        int temp = tab[i];
                        tab[i] = tab[j];
                        tab[j] = temp;
                        i++ ; j-- ;
                    }
                }
                if(j>l)
                {
                    Quicksort(tab, l, j);//rekurencyjne dzielenie podtablicy po lewej az do momentu kiedy zostanie 0 lub 1 element
                }
                if(i<r)
                {
                    Quicksort(tab, i, r);//rekurencyjne dzielenie podtablicy po prawej az do momentu kiedy zostanie 0 lub 1 element
                }
            }
        }
    }
}
